###code below created and run using Julia Version 1.10.0 (released on 25 December 2023)

##the code is split into 3 sections.
#1. Preliminaries: loads required packages and reads function files from the scripts subfolder.
#2. Replicate Results from the paper. After running Preliminaries, the user can run the code exactly as is to reproduce the results in Section 4 of the paper (Tables 2 and 3.)
#Runtimes may vary slightly from those in the paper, but all other results should be identical.
#The code reads in the data generated by the authors (saved in data) which was used to produce the results in Section 4.
#3. Run a new experiment. After running Preliminaries, the user can edit the parameters in this section to run a new experiment.
#The new experiment will have the the same structure as that from Section 4 of the paper, just different experiment parameters. The data generated for the new experiment will also be saved.

##################################################################################################################################################
############################ 1. Preliminaries
###run the commented out code below if need to install any of the packages used
#import Pkg
#Pkg.add("insert_package_name")

###packages used
using Distributions
using Combinatorics
using Printf
using JuMP
using GLPK 
using Random
using LinearAlgebra
using CSV
using DataFrames

#set working directory to the folder containing this main.jl file
cd(@__DIR__)

###functions used. For each, the file name is the same as the function name

#creates a matrix game where the searcher can choose from Gittins index sequences against p0. Used both in Algorithm 10 and Proposition 4 test
include("scripts/createLPmatp0.jl")

#finds conditional expected search times when the searcher plays a Gittins index sequence against a given hiding strategy. Used in Algorithm 10
include("scripts/find_cond_ests.jl")

# to solve matrix games (using linear programming)
include("scripts/solveLP_constr.jl") #solves the constrained matrix game in step 3 of Algorithm 10
include("scripts/solveLP.jl") #solves a standard matrix game, used for Propostion 4 test

#calculates the lower bound for p*_1...p*_n from the paper (Proposition 8), used in Algorithm 10
include("scripts/calc_lower_bound.jl") 

#to run Algorithm 10
include("scripts/run_algorithm10.jl")

#to run Proposition 4 test
include("scripts/run_proposition4.jl")

#used to run a whole numerical experiment
include("scripts/reproduce_experiment_from_stored_data.jl") #version to replicate the results in Tables 2 and 3 from the paper (called in code section 2 below)
include("scripts/run_new_experiment_by_drawing_data.jl") #version drawing new data using equation (23) from the paper (called in code section 3 below)


#####################################################################################################################################################
################## 2. replicate the results from the paper
###output is saved in results/results_from_paper. The code automatically creates new folders.
#See README.md for explanation of output names, and reproduce_experiment_from_stored_data.jl for explanation of output content.

##experiment parameters (and their explanations) to replicate the results in the paper. Do not change. If want to run a new experiment with new parameter values, see code section 3 named "run a new experiment" below.

#when calculating upper and lower bounds on an expected search time, we continue until the bounds are within 1 + 10^(-accuracy)
#for more details, see the end of Section 4.1 in the paper, where the value 1+10^(-10) is proposed
accuracy = 10

#bound_factor is what we multiply the non-strict lower bound (called η_i) for p^*_i from Propositon 8 by to obtain a strict lower bound (called δ_i) for p^*_i 
#for more details, see the discussion in the paper immediately following the proof of Proposition 8
bound_factor = 0.99

#δ is the distance that p_i found in Step 3 of Algorithm 10 and the strict lower bound on p^*_i (called δ_i) have to be within to be classed as `equal`. 
#When they are equal, equation (11) is binding and the second convergence critereon in Step 5 of Algorithm 10 is not satisfied.
δ = 0.000001

#ϵ determines how close the upper and lower bounds on the value of the game have to be before the first convergence critereon in Step 5 of Algorithm 10 is satisfied.
#ϵ=10^(-6) for all results in Table 2, whilst ϵ=10^(-6), 10^(-3) are compared for the varied sample scheme in Table 3. See Section 4.2 in the paper for more details. 
ϵ_values = [0.000001, 0.001]

#algorithm 10 will stop if max_iters is exceeded
max_iters = 1000

#δp0 is used in the Proposition 4 test. 
#the proposition 4 test solves the search game G_D, and compares its value v to the expected search time e if the hider plays p0 and the searcher optimally counters.
#if v=e then p0 is optimal for the hider. Here, due to numerical error when solving a matrix game, we accept equality if (v-e)/v < δp0, where δp0 is a user input
#the value below (10^-9) is discussed in the paper - see Section 4.2
δp0 = 0.000000001 #is the proposition test.

#quan_vec determines the quantiles to be used when calculating the summary statistics in Tables 2 and 3 (see Section 4.2 in the paper)
quan_vec = [0.95]

#search game parameters chosen at the start of Section 4 in the paper
box_sizes = [2 ,3, 5, 8] #number of boxes in a search game
#NOTE: running n=8 for N=8000 problems can take a couple of hours
#box_sizes = [2, 3, 5] #number of boxes in a search game - if want quicker runtime
sample_schemes = ["Varied", "Low", "Medium", "High"] #names of different sampling schemes.
detection_probs = [[0.1,0.9], [0.1,0.5], [0.3,0.7], [0.5,0.9]] #detection probabilities of the sampling schemes used in equation (23)
up_t = 5. #upper value of search times is fixed in (23)

##loop through different parameters
###output is saved in results/results_from_paper. The code automatically creates new folders.
for n in box_sizes

    @printf "Running code for %d boxes.\n" n

    N = n*1000 #number of search games in experiment 

    for j in 1:length(sample_schemes)

        @printf "Running for sample scheme %s.\n" sample_schemes[j]

        if j == 1 #only run both ϵ_values for the varied sample scheme - to produce the values in Table 3
            for ϵ in ϵ_values
                @printf "Running for ϵ =%f for sample scheme %s.\n" ϵ sample_schemes[j]
                reproduce_experiment_from_stored_data(n, N, detection_probs[j][1], detection_probs[j][2] , up_t, accuracy ,δ ,ϵ , δp0, bound_factor, quan_vec, max_iters) 
            end
        else
            reproduce_experiment_from_stored_data(n ,N, detection_probs[j][1], detection_probs[j][2], up_t, accuracy, δ, ϵ_values[1], δp0, bound_factor, quan_vec, max_iters) 
        end
    end
end


#####################################################################################################################################################
############################ 3. run a new experiment
###output is saved in results/new_experiments. The code automatically creates new folders. 
#See README.md for explanation of output names, and run_new_experiment_by_drawing_data.jl for explanation of output content.

##the parameters used to generate search games in (23)
low_q = 0.2; up_q = 0.8 #upper and lower detection probabilities labelled α_l and α_u in the paper 
up_t = 5. #upper search times, fixed as 5 in the paper.

n = 3; N = 1500 #number of boxes and number of search games to generate. NOTE: n>6 can start to take a few hours to run n*1000 problems. 

experiment_name = "my test" #will appear at the end of all output from the experiment

#for explanation of other parameters, see section "to replicate the results from the paper" above
quan_vec = [0.5,0.75,0.95,0.99] 
accuracy = 10
bound_factor = 0.99
δ = 0.000001
ϵ = 0.000001
δp0 = 0.000000001
max_iters = 1000

#output is saved in results/new_experiments. The code automatically creates new folders.
run_new_experiment_by_drawing_data(n, N, low_q, up_q, up_t, accuracy, δ, ϵ, δp0, bound_factor, quan_vec, max_iters, experiment_name) 
